# Домашно №1/1 по СДП-практикум за КН2, 8гр.
# Вариант 1
Това е единственото домашно по СДП-практикум за студентите, посещаващи практикума на група 8. Срокът му е до края на семестъра, като дотогава са позволени неограничен брой предавания. За всяко предадено по-рано домашно ще давам кратка обратна връзка. Домашното може да ви донесе най-много 20т., като има възможности за бонус (т.е. изкарване на >100%).

## Част 1: Имплементация (5т.)
Имплементирайте `class Sequence`, който представлява опростена линейна структура от данни тип `int` и поддържа поне следните операции:

```c++
class Sequence
{
public:
    // Конструира структурата и я запълва с count на брой числа.
    // Стойността на съдържаните числа няма значение.
    Sequence(size_t count = 4);

    // Ако не управлявате ръчно динамичната памет, можете да ги оставите
    // по подразбиране или с "... = default;", или като премахнете декларациите.
    Sequence(const Sequence& other);
    Sequence& operator=(const Sequence& other);

    // Премахва всички съдържани в структурата данни, оставяйки я празна.
    void clear();

    // Добавя числото x в "края" на структурата.
    void push_back(int x);

    // Добавя числото x на позиция position в структурата,
    // премествайки всички числа след нея с една позиция вдясно.
    // Ако позицията е невалидна (position > size), нека
    // добавянето бъде на позиция position % size.
    void insertAt(size_t position, int x);

    // Премахва числото, намиращо се на позиция position,
    // премествайки всички числа след нея с една позиция вляво.
    // Ако позицията е невалидна (position > size), нека
    // премахването бъде от позиция position % size.
    void removeAt(size_t position);

    // БОНУС (2т.): move-конструктор и move-оператор за присвояване
    Sequence(Sequence&& other);
    Sequence& operator=(Sequence&& other);
};
```

Тук начинът на представяне на данните в паметта може да бъде последователен (масив) или свързан (списък). Можете да използвате стандартната библиотека - забележете приликата с методите на повечето контейнери в нея. Можете да използвате и други (ваши или не) готови имплементации. **Важно:** целта на това домашно не е да направите възможно най-сложната структура от данни за 1/4 от точките.

Можете да добавяте колко и каквито искате методи и член-данни, стига да не променяте съществуващия интерфейс. Позволено е и да шаблонизирате класа както пожелаете, ако имате нужда.

## Част 2: Benchmarking (12т.)
Имплементирайте две версии на тази структура - една с последователно представяне в паметта и една със свързано. Използвайки стандартните библиотеки `<chrono>` и `<random>` (изискват поне c++11), измерете бързодействието на двете структури в следните ситуации:
* конструиране с n елемента
* последователно добавяне на n елемента в "края" на структурата
* последователно добавяне на n елемента на произволни позиции
* последователно премахване на n елемента от произволни позиции
* обикновено присвояване с `operator=` (copy-assignment) - тук има значение колко елемента се съдържат в момента на присвояване
* **бонус:** присвояване с преместване (move-assignment)

Имплементирайте функции, които тестват двете структури по горните няколко теста и изчисляват коя операция точно колко време отнема (в милисекунди) при даден брой елементи - напр. `double testRandomInsert(size_t n)`. Те могат да бъдат методи на класа, или външни функции, както вие прецените. Сравнете кои операции какво време отнемат в зависимост от размера на структурата - кога, например, е по-бързо конструирането със 100 елемента - при свързаното или последователното представяне в паметта? Ами при 20 милиона елемента? Защо?

Добра идея е да компилирате в 64-битов release режим. Отмервайте времето в милисекунди, т.к. секундите са неточни и *задължително* повторете всеки един тест по няколко пъти, за да получите средното време. Добавянето на допълнителни смислени тестове също ще бъде възнаградено с бонус.

## Част 3: Синтезиране на резултатите (3т.)
Съберете в един файл (какъвто пожелаете формат) резултатите от всички тестове върху двете структури от данни. Можете да направите само по 5-6 теста на операция, стига те да покриват достатъчно широк интервал, например n = 10-100-1000-10000-1млн.-10млн. Добавете и кратко обяснение, в 1-2 изречения, как вие интерпретирате получените резултати и на какво се дължат според вас. Няма нужда да пишете есета, с няколко думи ще ви разбера.

**Бонус (2т.):** напишете за всяка една операция колко точно е сложността по време в зависимост от представянето на структурата в паметта.

**Още бонус (3т.):** как биха изглеждали резултатите, ако работихме нe с int-ове, ами с други данни, като string-ове или по-сложни структури? Защо?

## Относно предаването
В мудъл ще бъде отворена форма за предаване (soon). Предавайте само по един-единствен .zip файл, в който включете всички ваши файлове - тези с кода ви и файла с резултатите. Крайният срок е далеч, но по-ранното предаване се насърчава.
